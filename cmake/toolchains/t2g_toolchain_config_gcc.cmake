# Note: Build config dependent options are specified in corresponding toolchain file!
#       (e.g. generation of debug symbols, optimization level, NDEBUG define)


###################################################################################################
# C Compiler
###################################################################################################

include(${CMAKE_SOURCE_DIR}/cmake/toolchains/toolchain-gcc.cmake)

set(C_COMPILER_OPTIONS
    -std=c99
    -Wall
)

set(C_COMPILER_OPTIONS_cm0plus
    -mcpu=cortex-m0plus
)

set(C_COMPILER_OPTIONS_cm4
    -mcpu=cortex-m4
    -mfloat-abi=hard
)

set(C_COMPILER_OPTIONS_cm7
    -mcpu=cortex-m7
    -mfloat-abi=hard
)


###################################################################################################
# CXX Compiler
###################################################################################################

set(CXX_COMPILER_OPTIONS
    ${C_COMPILER_OPTIONS}
)

set(CXX_COMPILER_OPTIONS_cm0plus
    ${C_COMPILER_OPTIONS_cm0plus}
)
set(CXX_COMPILER_OPTIONS_cm4
    ${C_COMPILER_OPTIONS_cm4}
)
set(CXX_COMPILER_OPTIONS_cm7
    ${C_COMPILER_OPTIONS_cm7}
)


###################################################################################################
# Assembler
###################################################################################################

set(ASSEMBLER_OPTIONS
    ${C_COMPILER_OPTIONS}
)

set(ASSEMBLER_OPTIONS_cm0plus
    ${C_COMPILER_OPTIONS_cm0plus}
)
set(ASSEMBLER_OPTIONS_cm4
    ${C_COMPILER_OPTIONS_cm4}
)
set(ASSEMBLER_OPTIONS_cm7
    ${C_COMPILER_OPTIONS_cm7}
)


###################################################################################################
# Linker
###################################################################################################

# Generic and CPU type specific linker options (does not include option to specify the linker file)
# Linker will be called through compiler driver, so some options may need to be prepended with -Wl
set(LINKER_OPTIONS
    ${C_COMPILER_OPTIONS}
    -nostartfiles
    --specs=nano.specs # Link with 'newlib-nano', comment this line to link with regular 'newlib' that provides more features, but requires more ROM/RAM
    -Wl,-Map=%
    -Wl,-e_start
)
set(LINKER_OPTIONS_cm0plus
    ${C_COMPILER_OPTIONS_cm0plus}
)
set(LINKER_OPTIONS_cm4
    ${C_COMPILER_OPTIONS_cm4}
)
set(LINKER_OPTIONS_cm7
    ${C_COMPILER_OPTIONS_cm7}
)

#--------------------------------------------------------------------------------------------------
# Additional toolchain specific libraries to link
set(TOOLCHAIN_LIBS
    c # 'libc' is linked automatically because neither -nodefaultlibs nor -nostdlib is specified, but we add it explicitly to solve circular dependencies
    m # 'libm' is not linked by default (math functions in GCC are not part of the normal 'libc')
)

# GCC by default scans libraries for missing symbols only once, this is a problem in case of circular dependencies so the following
# options are used before/after the library the re-scan them (alternative method would be to pass all libraries multiple times on the command line)
set(LINKER_OPTION_PRE_LINK_LIBS   -Wl,--start-group)
set(LINKER_OPTION_POST_LINK_LIBS  -Wl,--end-group)

#--------------------------------------------------------------------------------------------------
set(LINKER_FILE ${CMAKE_SOURCE_DIR}/${DIE}/tools/gcc/linker_directives.ld)

# Link step of executable will depend on these files
set(LINK_DEPENDENCY_FILES ${LINKER_FILE})

# Returns the linker option specific to the linker file(s). The function implementation and parameters allow
# a target / CPU Instance specific handling of the linker file (e.g. as required by GCC to preprocess the linker file)
# Note: It is recommended to pass linkerDefines as a string, e.g.: "${LIST_OF_LINKER_DEFINES}"
function(get_linker_file_option outVar targetName cpuTypeInstance linkerDefines)
    
    # Define output file name for the linker file that is generated by pre-processing
    set(preprocessedLinkerFile ${CMAKE_BINARY_DIR}/$<CONFIG>/preprocessed_linker_file_${cpuTypeInstance}.ld)

    # Convert the linker defines to toolchain specific linker options
    get_converted_linker_defines(linkerDefinesConverted ${linkerDefines} ${ARGN}) # Add ARGN in case caller forgot to pass linker defines as string

    # Add a pre-link dependency to the current executable which will call GCC to preprocess the linker file with appropriate defines (MCU revision, link location, CPU type/instace, ...)
    add_custom_command(TARGET      ${targetName} 
                       PRE_LINK
                       COMMAND     ${CMAKE_C_COMPILER}
                       ARGS        -E -xc -CC -P ${linkerDefinesConverted} -o ${preprocessedLinkerFile} ${LINKER_FILE}
                       BYPRODUCTS  ${preprocessedLinkerFile}
                       COMMENT     "Preprocess linker file: ${LINKER_FILE} --> ${preprocessedLinkerFile}"
    )

    # Return the linker option that specifies the linker file
    set(${outVar} -Wl,-T${preprocessedLinkerFile} PARENT_SCOPE)

endfunction()



